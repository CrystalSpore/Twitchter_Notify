"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var ircv3_1 = require("ircv3");
var UserTools_1 = require("../Toolkit/UserTools");
var _1 = require("./Capabilities/TwitchTags/");
var _2 = require("./Capabilities/TwitchCommands/");
var TwitchMembership_1 = require("./Capabilities/TwitchMembership");
var _3 = require("ircv3/lib/Message/MessageTypes/Commands/");
var ClearChat_1 = require("./Capabilities/TwitchCommands/MessageTypes/ClearChat");
var HostTarget_1 = require("./Capabilities/TwitchCommands/MessageTypes/HostTarget");
var RoomState_1 = require("./Capabilities/TwitchCommands/MessageTypes/RoomState");
var UserNotice_1 = require("./Capabilities/TwitchCommands/MessageTypes/UserNotice");
var Whisper_1 = require("./Capabilities/TwitchCommands/MessageTypes/Whisper");
var Decorators_1 = require("../Toolkit/Decorators");
var PrivateMessage_1 = require("./StandardCommands/PrivateMessage");
var ChatClient = /** @class */ (function (_super) {
    __extends(ChatClient, _super);
    function ChatClient(username, token, twitchClient, debugLevel) {
        if (debugLevel === void 0) { debugLevel = 0; }
        var _this = _super.call(this, {
            connection: {
                hostName: 'irc-ws.chat.twitch.tv',
                nick: username.toLowerCase(),
                password: "oauth:" + token,
                secure: true
            },
            webSocket: true,
            debugLevel: debugLevel
        }) || this;
        _this.onTimeout = _this.registerEvent();
        _this.onBan = _this.registerEvent();
        _this.onChatClear = _this.registerEvent();
        _this.onEmoteOnly = _this.registerEvent();
        _this.onFollowersOnly = _this.registerEvent();
        _this.onHost = _this.registerEvent();
        _this.onHosted = _this.registerEvent();
        _this.onHostsRemaining = _this.registerEvent();
        _this.onJoin = _this.registerEvent();
        _this.onPart = _this.registerEvent();
        _this.onR9k = _this.registerEvent();
        _this.onUnhost = _this.registerEvent();
        _this.onSlow = _this.registerEvent();
        _this.onSubsOnly = _this.registerEvent();
        _this.onSub = _this.registerEvent();
        _this.onResub = _this.registerEvent();
        _this.onSubGift = _this.registerEvent();
        _this.onWhisper = _this.registerEvent();
        // internal events to resolve promises and stuff
        _this._onBanResult = _this.registerEvent();
        _this._onTimeoutResult = _this.registerEvent();
        _this._onUnbanResult = _this.registerEvent();
        _this._onColorResult = _this.registerEvent();
        _this._onCommercialResult = _this.registerEvent();
        _this._onEmoteOnlyResult = _this.registerEvent();
        _this._onEmoteOnlyOffResult = _this.registerEvent();
        _this._onFollowersOnlyResult = _this.registerEvent();
        _this._onFollowersOnlyOffResult = _this.registerEvent();
        _this._onHostResult = _this.registerEvent();
        _this._onUnhostResult = _this.registerEvent();
        _this._onModResult = _this.registerEvent();
        _this._onUnmodResult = _this.registerEvent();
        _this._onModsResult = _this.registerEvent();
        _this._onJoinResult = _this.registerEvent();
        _this._onR9kResult = _this.registerEvent();
        _this._onR9kOffResult = _this.registerEvent();
        _this._onSlowResult = _this.registerEvent();
        _this._onSlowOffResult = _this.registerEvent();
        _this._onSubsOnlyResult = _this.registerEvent();
        _this._onSubsOnlyOffResult = _this.registerEvent();
        _this._twitchClient = twitchClient;
        // tslint:disable:no-floating-promises
        _this.registerCapability(_1.default);
        _this.registerCapability(_2.default);
        _this.registerCapability(TwitchMembership_1.default);
        // tslint:enable:no-floating-promises
        _this.onMessage(ClearChat_1.default, function (_a) {
            var _b = _a.params, channel = _b.channel, user = _b.user, tags = _a.tags;
            if (user) {
                var duration = tags.get('ban-duration');
                var reason = tags.get('ban-reason');
                if (duration !== undefined) {
                    // timeout
                    _this.emit(_this.onTimeout, channel, user, reason, Number(duration));
                    _this.emit(_this._onTimeoutResult, channel, user, reason, Number(duration));
                }
                else {
                    // ban
                    _this.emit(_this.onBan, channel, user, reason);
                }
            }
            else {
                // full chat clear
                _this.emit(_this.onChatClear, channel);
            }
        });
        _this.onMessage(HostTarget_1.default, function (hostMessage) {
            var _a = hostMessage.params, channel = _a.channel, targetAndViewers = _a.targetAndViewers;
            var _b = targetAndViewers.split(' '), target = _b[0], viewers = _b[1];
            if (target === '-') {
                // unhost
                _this.emit(_this.onUnhost, channel);
            }
            else {
                _this.emit(_this.onHost, channel, target, viewers ? Number(viewers) : undefined);
            }
        });
        _this.onMessage(_3.ChannelJoin, function (joinMessage) {
            var prefix = joinMessage.prefix, channel = joinMessage.params.channel;
            _this.emit(_this.onJoin, channel, prefix.nick);
        });
        _this.onMessage(_3.ChannelPart, function (partMessage) {
            var prefix = partMessage.prefix, channel = partMessage.params.channel;
            _this.emit(_this.onPart, channel, prefix.nick);
        });
        _this.onMessage(PrivateMessage_1.default, function (msg) {
            var prefix = msg.prefix, _a = msg.params, channel = _a.target, message = _a.message;
            if (prefix && prefix.nick === 'jtv') {
                // 1 = who hosted
                // 2 = auto-host or not
                // 3 = how many viewers (not always present)
                var match = message.match(ChatClient.HOST_MESSAGE_REGEX);
                if (match) {
                    _this.emit(_this.onHosted, channel, match[1], Boolean(match[2]), match[3] === '' ? Number(match[3]) : undefined);
                }
            }
        });
        _this.onMessage(RoomState_1.default, function (stateMessage) {
            var channel = stateMessage.params.channel, tags = stateMessage.tags;
            var isInitial = false;
            if (tags.has('subs-only') && tags.has('slow')) {
                // this is the full state - so we just successfully joined
                _this.emit(_this._onJoinResult, channel, tags);
                isInitial = true;
            }
            if (tags.has('slow')) {
                var slowDelay = Number(tags.get('slow'));
                if (!slowDelay) {
                    _this.emit(_this._onSlowOffResult, channel);
                    if (!isInitial) {
                        _this.emit(_this.onSlow, channel, false);
                    }
                }
                else {
                    _this.emit(_this._onSlowResult, channel, slowDelay);
                    if (!isInitial) {
                        _this.emit(_this.onSlow, channel, true, slowDelay);
                    }
                }
            }
            if (tags.has('followers-only')) {
                var followDelay = Number(tags.get('followers-only'));
                if (followDelay === -1) {
                    _this.emit(_this._onFollowersOnlyOffResult, channel);
                    if (!isInitial) {
                        _this.emit(_this.onFollowersOnly, channel, false);
                    }
                }
                else {
                    _this.emit(_this._onFollowersOnlyResult, channel, followDelay);
                    if (!isInitial) {
                        _this.emit(_this.onFollowersOnly, channel, true, followDelay);
                    }
                }
            }
        });
        _this.onMessage(UserNotice_1.default, function (userNotice) {
            var _a = userNotice.params, channel = _a.channel, message = _a.message, tags = userNotice.tags;
            var messageType = tags.get('msg-id');
            if (messageType === 'sub' || messageType === 'resub') {
                var event_1 = messageType === 'sub' ? _this.onSub : _this.onResub;
                var plan = tags.get('msg-param-sub-plan');
                var subInfo = {
                    displayName: tags.get('display-name'),
                    plan: plan,
                    planName: tags.get('msg-param-sub-plan-name'),
                    isPrime: plan === 'Prime',
                    streak: Number(tags.get('msg-param-months')),
                    message: message
                };
                _this.emit(event_1, channel, tags.get('login'), subInfo, userNotice);
            }
            else if (messageType === 'subgift') {
                var plan = tags.get('msg-param-sub-plan');
                var subInfo = {
                    displayName: tags.get('msg-param-recipient-display-name'),
                    gifter: tags.get('login'),
                    gifterDisplayName: tags.get('display-name'),
                    plan: plan,
                    planName: tags.get('msg-param-sub-plan-name'),
                    isPrime: plan === 'Prime',
                    streak: Number(tags.get('msg-param-months'))
                };
                _this.emit(_this.onSubGift, channel, tags.get('msg-param-recipient-user-name'), subInfo, userNotice);
            }
        });
        _this.onMessage(Whisper_1.default, function (whisper) {
            _this.emit(_this.onWhisper, whisper.prefix.nick, whisper.params.message, whisper);
        });
        _this.onMessage(_3.Notice, function (notice) {
            var _a = notice.params, channel = _a.target, message = _a.message, tags = notice.tags;
            var messageType = tags.get('msg-id');
            // this event handler involves a lot of parsing strings you shouldn't parse...
            // but Twitch doesn't give us the required info in tags (╯°□°）╯︵ ┻━┻
            // (this code also might not do the right thing with foreign character display names...)
            switch (messageType) {
                // ban
                case 'already_banned': {
                    var match = message.split(' ');
                    var user = (match && /^\w+$/.test(match[0])) ? match[0] : undefined;
                    _this.emit(_this._onBanResult, channel, user, messageType);
                    break;
                }
                case 'bad_ban_self': {
                    _this.emit(_this._onBanResult, channel, _this._userName, messageType);
                    break;
                }
                case 'bad_ban_broadcaster': {
                    _this.emit(_this._onBanResult, channel, UserTools_1.default.toUserName(channel), messageType);
                    break;
                }
                case 'bad_ban_admin':
                case 'bad_ban_global_mod':
                case 'bad_ban_staff': {
                    var match = message.match(/^You cannot ban (?:\w+ )+?(\w+)\.$/);
                    _this.emit(_this._onBanResult, channel, match ? match[1].toLowerCase() : undefined, messageType);
                    break;
                }
                case 'ban_success': {
                    var match = message.split(' ');
                    var user = (match && /^\w+$/.test(match[0])) ? match[0] : undefined;
                    _this.emit(_this._onBanResult, channel, user);
                    break;
                }
                // unban
                case 'bad_unban_no_ban': {
                    var match = message.split(' ');
                    var user = (match && /^\w+$/.test(match[0])) ? match[0] : undefined;
                    _this.emit(_this._onUnbanResult, channel, user, messageType);
                    break;
                }
                case 'unban_success': {
                    var match = message.split(' ');
                    var user = (match && /^\w+$/.test(match[0])) ? match[0] : undefined;
                    _this.emit(_this._onUnbanResult, channel, user);
                    break;
                }
                // color
                case 'turbo_only_color': {
                    _this.emit(_this._onColorResult, messageType);
                    break;
                }
                case 'color_changed': {
                    _this.emit(_this._onColorResult);
                    break;
                }
                // commercial
                case 'bad_commercial_error': {
                    _this.emit(_this._onCommercialResult, channel, messageType);
                    break;
                }
                case 'commercial_success': {
                    _this.emit(_this._onCommercialResult, channel);
                    break;
                }
                // emote only
                case 'already_emote_only_on': {
                    _this.emit(_this._onEmoteOnlyResult, channel, messageType);
                    break;
                }
                case 'emote_only_on': {
                    _this.emit(_this._onEmoteOnlyResult, channel);
                    _this.emit(_this.onEmoteOnly, channel, true);
                    break;
                }
                // emote only off
                case 'already_emote_only_off': {
                    _this.emit(_this._onEmoteOnlyOffResult, channel, messageType);
                    break;
                }
                case 'emote_only_off': {
                    _this.emit(_this._onEmoteOnlyOffResult, channel);
                    _this.emit(_this.onEmoteOnly, channel, false);
                    break;
                }
                // host
                case 'bad_host_hosting':
                case 'bad_host_rate_exceeded':
                case 'bad_host_error': {
                    _this.emit(_this._onHostResult, channel, messageType);
                    break;
                }
                case 'hosts_remaining': {
                    var remainingHostsFromChar = +message[0];
                    var remainingHosts = isNaN(remainingHostsFromChar) ? 0 : Number(remainingHostsFromChar);
                    _this.emit(_this._onHostResult, channel);
                    _this.emit(_this.onHostsRemaining, channel, remainingHosts);
                    break;
                }
                // unhost (only fails, success is handled by HOSTTARGET)
                case 'not_hosting': {
                    _this.emit(_this._onUnhostResult, channel, messageType);
                    break;
                }
                // join (success is handled when ROOMSTATE comes in)
                case 'msg_channel_suspended': {
                    _this.emit(_this._onJoinResult, channel, undefined, messageType);
                    break;
                }
                // mod
                case 'bad_mod_banned':
                case 'bad_mod_mod': {
                    var match = message.split(' ');
                    var user = (match && /^\w+$/.test(match[0])) ? match[0] : undefined;
                    _this.emit(_this._onModResult, channel, user, messageType);
                    break;
                }
                case 'mod_success': {
                    var match = message.match(/^You have added (\w+) /);
                    _this.emit(_this._onModResult, channel, match ? match[1] : undefined);
                    break;
                }
                // unmod
                case 'bad_unmod_mod': {
                    var match = message.split(' ');
                    var user = (match && /^\w+$/.test(match[0])) ? match[0] : undefined;
                    _this.emit(_this._onUnmodResult, channel, user, messageType);
                    break;
                }
                case 'unmod_success': {
                    var match = message.match(/^You have removed (\w+) /);
                    _this.emit(_this._onUnmodResult, channel, match ? match[1] : undefined);
                    break;
                }
                // mods
                case 'no_mods': {
                    _this.emit(_this._onModsResult, channel, []);
                    break;
                }
                case 'room_mods': {
                    var _b = message.split(': '), modList = _b[1];
                    var mods = modList.split(', ');
                    _this.emit(_this._onModsResult, channel, mods);
                    break;
                }
                // r9k
                case 'already_r9k_on': {
                    _this.emit(_this._onR9kResult, channel, messageType);
                    break;
                }
                case 'r9k_on': {
                    _this.emit(_this._onR9kResult, channel);
                    _this.emit(_this.onR9k, channel, true);
                    break;
                }
                // r9k off
                case 'already_r9k_off': {
                    _this.emit(_this._onR9kOffResult, channel, messageType);
                    break;
                }
                case 'r9k_off': {
                    _this.emit(_this._onR9kOffResult, channel);
                    _this.emit(_this.onR9k, channel, false);
                    break;
                }
                // subs only
                case 'already_subs_on': {
                    _this.emit(_this._onSubsOnlyResult, channel, messageType);
                    break;
                }
                case 'subs_on': {
                    _this.emit(_this._onSubsOnlyResult, channel);
                    _this.emit(_this.onSubsOnly, channel, true);
                    break;
                }
                // subs only off
                case 'already_subs_off': {
                    _this.emit(_this._onSubsOnlyOffResult, channel, messageType);
                    break;
                }
                case 'subs_off': {
                    _this.emit(_this._onSubsOnlyOffResult, channel);
                    _this.emit(_this.onSubsOnly, channel, false);
                    break;
                }
                // timeout (only fails, success is handled by CLEARCHAT)
                case 'bad_timeout_self': {
                    _this.emit(_this._onTimeoutResult, channel, _this._userName, undefined, undefined, messageType);
                    break;
                }
                case 'bad_timeout_broadcaster': {
                    _this.emit(_this._onTimeoutResult, channel, UserTools_1.default.toUserName(channel), undefined, undefined, messageType);
                    break;
                }
                case 'bad_timeout_admin':
                case 'bad_timeout_global_mod':
                case 'bad_timeout_staff': {
                    var match = message.match(/^You cannot ban (?:\w+ )+?(\w+)\.$/);
                    _this.emit(_this._onTimeoutResult, channel, match ? match[1].toLowerCase() : undefined, undefined, undefined, messageType);
                    break;
                }
                case 'cmds_available': {
                    // do we really care?
                    break;
                }
                // there's other messages that show us the following things...
                // ...like ROOMSTATE...
                case 'followers_on':
                case 'followers_on_zero':
                case 'followers_off':
                case 'slow_on':
                case 'slow_off':
                // ...and CLEARCHAT...
                case 'timeout_success':
                // ...and HOSTTARGET
                case 'host_off':
                case 'host_on':
                case 'host_target_went_offline': {
                    break;
                }
                case 'unrecognized_cmd': {
                    break;
                }
                case null: {
                    // this might be one of these weird authentication error notices that don't have a msg-id...
                    if (message === 'Login authentication failed'
                        || message === 'Improperly formatted AUTH'
                        || message === 'Invalid NICK') {
                        _this._connection.disconnect();
                    }
                    break;
                }
                default: {
                    if (!messageType || messageType.substr(0, 6) !== 'usage_') {
                        console.warn("Unrecognized notice ID: '" + messageType + "'");
                    }
                }
            }
        });
        return _this;
    }
    ChatClient.prototype.host = function (target, channel) {
        if (channel === void 0) { channel = this._nick; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = UserTools_1.default.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onHostResult(function (chan, error) {
                            if (UserTools_1.default.toUserName(chan) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.sendMessage(PrivateMessage_1.default, { target: UserTools_1.default.toChannelName(channel), message: "/host " + target });
                    })];
            });
        });
    };
    ChatClient.prototype.unhost = function (channel) {
        if (channel === void 0) { channel = this._nick; }
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                channel = UserTools_1.default.toUserName(channel);
                return [2 /*return*/, new Promise(function (resolve, reject) {
                        var e = _this._onUnhostResult(function (chan, error) {
                            if (UserTools_1.default.toUserName(chan) === channel) {
                                if (error) {
                                    reject(error);
                                }
                                else {
                                    resolve();
                                }
                                _this.removeListener(e);
                            }
                        });
                        _this.sendMessage(PrivateMessage_1.default, { target: UserTools_1.default.toChannelName(channel), message: '/unhost' });
                    })];
            });
        });
    };
    ChatClient.prototype.unhostOutside = function (channel) {
        if (channel === void 0) { channel = this._nick; }
        this.sendMessage(PrivateMessage_1.default, { target: UserTools_1.default.toChannelName(channel), message: '/unhost' });
    };
    ChatClient.prototype.registerCoreMessageTypes = function () {
        _super.prototype.registerCoreMessageTypes.call(this);
        this.registerMessageType(PrivateMessage_1.default);
    };
    ChatClient.HOST_MESSAGE_REGEX = /(\w+) is now ((?:auto[- ])?)hosting you(?: for (?:up to )?(\d+))?/;
    __decorate([
        Decorators_1.NonEnumerable
    ], ChatClient.prototype, "_twitchClient", void 0);
    return ChatClient;
}(ircv3_1.Client));
exports.default = ChatClient;
//# sourceMappingURL=ChatClient.js.map